# 线性表

## 线性表的链式表示

### 头指针，头节点，首元节点

头指针：指向链表中第一个节点的指针

首元节点：指链表中存储第一个元素的节点

头节点：在链表的首元节点之前附设的一个节点

### 如何表示空表

无头节点时，头指针为空表示空表

有头节点时，头节点的指针域为空表示空表

### 链表中设置头节点的好处

1. 便于首元节点的处理，首元节点的地址保存在头节点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理
2. 便于空表和非空表 的统一处理，无论链表是否为空，头指针都是指向头节点的非空指针，因此空表和非空表的处理也就统一了

### 头节点的数据域

可以为空，也可以存放线性表长度等附加信息，但此节点不计入链表长度

### 链表（链式存储结构） 的特点

1. 节点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
2. 访问时只能通过头指针进入链表，并通过每个节点的指针域一次向后顺序扫描其余节点，所以寻找第一个节点和最后一个节点所花的时间不等，这种存取元素的方法被称为顺序存取法

### 单链表

#### 单链表销毁

```c++
Lnode *p;
while(head!=NULL){
    p = head;
    head = head->next;
    delete p;
}
```

#### 单链表清空

链表仍存在，但链表中无元素，成为空链表（头指针和头节点仍然在）

```c++
Lnode *p;
Lnode *q;
p = head->next;
while(p!=NULL){
    q = p->next;
    delete p;
	p = q;
}
head->next = NULL;//头节点置为空
```

#### 单链表求表长

```c++
Lnode *p;
p = head->next;
int i = 0;
while(p!=NULL){
    i ++;
    p = p->next;
}
```

#### 单链表取值

```c++
Lnode *p;
p = head->next;
int j = 1;
while(p!= NULL && j < i){
    p = p->next;
    j ++;
}
//此时查询的数据为p所指的节点的data域
```

#### 单链表查找

按值查找

```c++
Lnode *p;
p = head->next;
while(p!=NULL && p->data!=e){
    p = p->next;
}
//可以return地址p或位置序号
```

#### 单链表插入

```c++
Lnode *p;
p = head;
j = 0;
while(p!=NULL && j < i - 1){
	p = p->next;
    j ++;
}
s = new Lnode;
s->data = e;
s->next = p->next;
p->next = s;
```

#### 单链表删除

```c++
Lnode *p;
Lnode *q;
p = head;
j = 0;
while(p->next && j < i - 1){
    p = p->next;
    j ++;
}
q = p->next;
p->next = q->next;
e = q->data;
delete q;
```

#### 单链表创建

##### 前插法

1. 从一个空表开始，重复读入数据
2. 生成新节点，将读入数据存放到新节点的数据域中
3. 从最后一个节点开始，依次将各节点插入到链表的前端

```c++
L = new Lnode;
L->next = NULL;
for(i = n;i > 0;i --){
    p = new Lnode;
    cin>>p->data;
    p->next = L->next;
    L->next = p;
}
```

##### 后插法

1. 从一个空表L开始，将新节点逐个插入到链表的尾部，尾指针r指向链表的尾节点
2. 初始时，r和L均指向头节点，每读入一个数据元素则申请一个新节点，将新节点插入到尾节点后，r指向新节点

```c++
L = new Lnode;
Lnode *r;
L->next = NULL;
r = L;
int i;
for(i = 0;i < n;i ++){
    p = new Lnode;
    cin>>p->data;
    p->next = NULL;
    r->next = p;
    r = p;
}
```

#### 循环链表

是一种头尾相接的链表，即表中最后一个节点的指针域指向头节点，整个链表形成一个环

优点：从表中任一节点出发均可找到表中其它节点

头节点的指针域存放头指针，即指向自己

注意：由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件为判断它们是否等于头指针

由于表的操作常常在表的首尾位置上进行，所以可以使用尾指针表示单循环链表，首元节点为r->next->next，尾节点为r

##### 带尾指针循环链表的合并

```c++
Lnode *p;
p = Ra->next;
Ra->next = Rb->next->next;
delete Rb->next;
Rb->next = p;
```

### 双向链表

相较于单链表多了一个prior指针指向节点前趋

双向链表的头节点的prior为空，尾节点next为空

空表的头节点的prior和next都为空

#### 双循环链表

1. 让头节点的prior指向链表的尾节点
2. 让尾节点的next指向头节点

双向链表的对称性：`p->prior->next = p = p->next->prior`

#### 双向链表插入

```c++
s = new Dnode;
s->data = e;
s->prior = p->prior;
p->prior->next = s;
s->next = p;
p->prior = s;
```

#### 双向链表删除

```c++
p->prior->next = p->next;
p->next->prior = p->prior;
delete p;
```

### 顺序表和链表的比较

- 链式存储结构的优点

  - 结点空间可以动态申请和释放
  - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要一定数据元素

- 链式存储结构的缺点

  - 存储密度小，每个结点的指针域需额外占用存储空间，当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大

    存储密度 = 结点数据本身占用的空间/结点占用的空间总量

  - 链式存储结构是非随机存储结构，对任一结点的操作都要从头指针依指针链查找到该结点，增加了算法的复杂度

顺序表适用情况：

1. 表长变化不大，且能事先确定变化的范围
2. 很少进行插入或删除操作，教程按元素位置序号访问数据元素

链表适用情况：

1. 长度变化较大
2. 频繁进行插入或删除操作

## 线性表的应用

### 线性表的合并

将两个线性表a,b合并，求新表aUb

思路：遍历线性表b中每个元素，查询a表中是否有该元素，如果没有，则插入a表

### 有序表的合并

将两个有序线性表合并，要求合并后的新表仍然有序

思路：

1. 创建一个空表c
2. 依次从a或b中选择元素值较小的结点插入c表的最后，直至其中一个表为空为止
3. 继续将a或b其中一个表的剩余结点插入在c表的最后

# 栈和队列

栈和队列是限定插入和删除只能在表的“端点”进行的线性表

## 栈

限定只能在表的一端进行插入和删除运算的线性表（只能在栈顶操作）

栈先进后出，后进先出（LIFO结构）

如果问题求解的过程具有后进先出的特性的话，求解的算法中必然需要利用栈

如：

- 数制转换
- 表达式求值
- 括号匹配检验
- 八皇后问题
- 行编辑程序
- 函数调用
- 迷宫求解
- 递归调用的实现

### 顺序栈

利用一组地址连续存储单元依次存放自栈底到栈顶的数元素，栈底一般在低地址端

- 另附top指针，指示栈顶元素在顺序栈中的位置
- 另附base指针，只是栈底元素在顺序栈中的位置
- 但是，为了方便操作，通常top指示真正的栈顶元素之上的下标地址
- base == top 是空栈标志
- top - base == stacksize 是满栈标志

### 链栈

链栈是运算受限的单链表，只能在链表头部进行操作

- 链表的头指针就是栈顶
- 不需要头节点
- 基本不存在栈满的情况
- 空栈相当于头指针指向空
- 插入和删除仅在栈顶处执行

### 栈与递归

- 具有递归特性的数据结构
  - 二叉树
  - 广义表



## 队列

队列是一种先进先出（FIFO）的线性表，在表一端插入（表尾），在另一端（表头）删除

- 脱机打印输出：按申请的先后顺序依次输出
- 多用户系统中，多个用户排成队，分时的循环使用CPU和主存
- 按用户的优先级排成多个队，每个优先级一个队列
- 实时控制系统中，信号按接受的先后顺序依次处理
- 网络电文传输，按到达的时间先后顺序依次进行

### 顺序队列

顺序队列有两个指针front和rear

入队时rear++

出队时front++

顺序队列存在假溢出情况，即rear指向末尾，但队列前端为空。

解决方法：将队列想像成一个循环的表，当rear指向maxsize时，如果队列前端为空，则rear执行队列前端，当front为maxsize时同样

指针移动：`rear = (rear + 1) % maxsize`

判断队满：`(rear + 1) % maxsize == fron`   解释：少用一个空间，当尾指针追上头指针时队满

求队列长度：`(rear - front  + maxsize) % maxsize`

### 链队

设置头指针，头节点，尾指针

出队时直接将头节点指向首元结点的下一结点

入队时让尾指针的下一节点指向新结点

## 栈和队列案例

### 进制转换

- 十进制整数向其它进制数转换

转换法则：除以d（进制数）倒取余

即：将十进制数不断除以d，直到余数为0，将余数倒着列出来即为转换后的数

### 表达式求值

- 设置两个栈，运算符栈op，操作数栈num

- 从左至右扫描每一个字符，扫描到的是运算数则压入num，扫描到运算符时：
  - 若这个运算符比op栈顶运算符的优先级高，则入栈op
  - 若这个运算符比op栈顶运算符优先级低或同等，则弹出op栈顶运算符，弹出两个操作数，计算后压入栈num
  - 如果运算符为（  则压入op，如果为  ）则使用op栈顶运算符运算，直到栈顶为（
- 继续向后扫描，直到遇到结束符

# 串，数组，广义表

## 串

**子串：**一个串中任意个连续字符组成的子序列（含空串）称为改串的子串

**真子串：**不包含自身的所有子串

**字符位置：**字符在序列中的序号

**子串位置：**子 串第一个字符在主串中的位置

**空格串：**由一个或多个空格组成的串，与空串不同

**串相等：**当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，两个串才相等

### 字符串匹配

算法目的：确定主串中所含子串第一次出现的位置（定位）

算法种类：

- BF算法（暴力）
- KMP算法

#### BF算法

思路：从主串的每一个字符开始依次与字串的字符进行匹配

设i为主串计数器，j为字串计数器，出现匹配失败后:

`i = i - j + 1;`

`j = 0;`

```c++
//核心代码
int i = 0;
int j = 0;
while(i < S.length && j < T.length){
    if(S[i] == T[j]){
        i ++;
        j ++;
    }else{
        i = i - j + 1;
        j = 0;
    }
}
if(j >= T.length) return i - j;
if(i >= S.length) return -1;
```

#### KMP算法

定义next[j]数组，当子串中第j个字符与主串失配时，在子串中需重新和主串中改字符进行比较的字符的位置

失配时，观察此时j的左边，找到最长公共前缀，公共后缀，最长公共前后缀小于左边的子串长度

若子串下标从1开始，则下一次主串失配字符 与子串最长公共前后缀的长度+1上的字符比较

若子串下标从0开始，则下一次主串失配字符与子串最长公共前后缀的长度上的字符比较

若失配字符左边无公共前缀后缀，则下一次主串失配字符与子串第一个字符比较，如果子串下标从1开始，那么此时next[j]中存入0，下次循环i++,j++

若主串第一个字符与子串第一个字符不等，则下一次由主串下一个元素比较

```c++
int i = 1;
int j = 1;
while(i <= s.length && j <= t.length){
    if(j == 0 || s[i] == t[j]){
        i ++;
        j ++;
    }else j = next[j];
}
```

```c++
//求next数组 细细品
int i = 1;
next[1] = 0;
int j = 0;
while(i < t.length){
    if(j == 0 || t[i] == t[j]){
        i ++;
        j ++;
        next[i] = j;
    }else j = next[j];
}
```

## 数组

### 矩阵压缩

没记笔记，考到再说，我觉得用处不大

## 广义表

广义表通常记作：LS = (a1,a2,······,an)

广义表每个元素可以类型不同，元素也可以为广义表，元素为广义表时带括号，大写字母代表广义表，小写字母代表原子

1. 广义表中的数据元素有相对次序。一个直接前驱，一个直接后驱
2. 广义表的长度定义为最外层所包含元素的个数
3. 广义表的深度定义为改广义表展开后所含括号的层数
4. 广义表可以为其它广义表共享
5. 广义表可以是一个递归的表，此时深度为无穷
6. 广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素也可以是子表

# 树

## 树的定义

树（Tree）是n（n>=0）个结点的有限集

若n = 0，称为空树

若n > 0，则它满足如下两个条件：

1. 有且仅有一个特点的称为根（Root）的结点；
2. 其余结点可分为m（m>=0）个互不相交的有限集T1，T2，T3，...，Tm，其中每一个集合本身又是一棵树，并称为根的子树



根结点：非空树无前驱结点的结点

结点的度：结点所拥有的子树数

树的度：树内各结点的度的最大值

度为0：称为叶子，为终端结点

结点的子树的根称为该结点的孩子，该结点称为孩子的父亲

结点的祖先：从根到该结点所经分支上的所有结点

结点的子孙：以某结点为根的子树中的任一结点

树的深度：树中结点的最大层次

有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子），反正称为无序树

森林：是m(m>= 0)棵互不相交的树的集合，把根结点删除树就变成了森林，一棵树可以看成一个特殊的森林

## 二叉树

每个结点最多有两个孩子

子树有左右之分，次序不能颠倒

二叉树可以是空集合，根可以有空的左子树或空的右子树

二叉树结点的字数要区分左子树和右子树，只有一棵子树也要区分它是左子树还是右子树，树只有一棵子树时不需要区分

### 二叉树的性质

1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1) ,最少有1个

2. 深度为k二叉树至多有2^k - 1个结点（k>=1)，最少有k个

3. 队任何一棵二叉树T，如果其叶子数为n0，度为2的结点数为n2，则n0 = n2 + 1

4. 具有n个结点的完全二叉树的深度为[log2 n]+1  

   [ x]意思是不大于x的最大整数

5. 如果对一棵有n个结点的完全二叉树（深度为[log2 n] + 1）的结点按层序编号（从第1层到第[log2 n] + 1层，每层从左到右），则对任一结点i（i<=i<=n），有

   - 如果i = 1，则结点i是二叉树的根，无父亲；如果i > 1，则其父亲是结点[i/2]
   - 如果2i > n，则结点i为叶子节点，无左孩子；否则，其左孩子是节点2i
   - 如果2i + 1 > n，则节点i无右孩子；否则，其右孩子是结点2i + 1

### 满二叉树

一棵深度为k且有2^k - 1个结点的二叉树称为满二叉树

特点：

1. 每一层上的结点数都是最大结点数
2. 叶子结点全部在最底层

编号时从根结点开始从上到下，从左到右

### 完全二叉树

深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称之为完全二叉树

主要看编号和二叉树是不是一一对应的。

在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树

### 二叉树的存储结构

#### 二叉树的顺序存储

实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素

顺序存储缺点：最快情况下浪费空间，深度为k的且之有k个结点的单支树需要长度为2^k - 1 的一维数组

顺序存储适合满二叉树和完全二叉树

#### 二叉树的链式存储结构

每个结点有一个data域，两个指针域

在n个结点的二叉链表中，有n + 1 个空指针域

三叉链表：再增加一个指针域，指向它的前驱

### 遍历二叉树

顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次

遍历顺序：DLR 先（根）序遍历，LDR 中（根）序遍历，LRD 后（根）序遍历，递归调用

根据遍历顺序求二叉树，必须有中序，可以为先序和中序或后序和中序，前序的第一个一定为根结点，后序的最后一个一定为根结点

```c++
//先序遍历
void pre(BTree *p){
    if(p != NULL){
        cout<<t->data<<endl;
        pre(p->lchild);
        pre(p->rchild);
    }
}

//中序遍历
void pre(BTree *p){
    if(p != NULL){
        pre(p->lchild);
        cout<<p->data<<endl;
        pre(p->rchild);
    }
}
```

#### 中序遍历非递归算法

1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根结点出栈，输出根结点，遍历右子树

```c++
void xxx(BTree*& t){
    BTree* p;
    BTree* q;
    p = t;
    InitStack(s);
    while(p || !StackTmpty(s)){
        if(p){
            push(s,p);
            p = p->lchild;
        }else{
            pop(s,q);
            cout<<q->data<<endl;
            p = q->rchild;
        }
    }
}
```

#### 二叉树的层次遍历

1. 使用一个队列，将根节点入队
2. 队不空时循环：从队列中出列一个结点*p，访问它；
   - 如果它有左孩子结点，将左孩子结点进队
   - 如果它有右孩子结点，将右孩子结点进队

## 二叉树遍历的应用

### 二叉树创建

```c++
void createBTree(BTree& t){
    cin>>ch;
    if(ch == "#") t = NULL;
    else{
        t = new BTree*;
        t->data = ch;
        createBTree(t->lchild);
        createBTree(t->rchild);
    }
}
```

### 复制二叉树

```c++
int copy(BTree t,BTree& newt){
    if(t == NULL){
        newt = NULL;
        return 0;
    }else{
        newt = new BTree*;
        newt->data = t->data;
        copy(t->lchild,newt->lchild);
        copy(t->rchild,newt->rchild);
    }
}
```

### 计算二叉树深度

- 如果是空树，则深度为0
- 否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1

```c++
int depth(BTree t){
    if(t == NULL) return 0;
    else{
        m = depth(t->lchild);
        n = depth(t->rchild);
        if(m > n) return (m + 1);
        else return (n + 1);
    }
}
```

### 计算二叉树结点数

- 如果是空树，则结点数为0
- 否则，结点个数为左子树的结点个数+右子树的结点个数再+1

```c++
int NodeCount(BTree t){
    if(t == NULL) return 0;
    else{
        return NodeCount(t->lchild) + NodeCount(t->rchild) + 1;
    }
}
```

### 计算二叉树叶子结点数

- 如果是空树，则叶子结点个数为0
- 否则，为左子树的叶子结点个数+右子树叶子结点个数

```c++
int leadc(BTree t){
    if(t == NULL) return 0;
    if(t->lchild == NULL && t->rchild == NULL) return 1;
    else{
        return leadc(t->lchild) + leadc(t->rchild);
    }
}
```

## 线索二叉树

具有n个结点的二叉链表中，一共右2n个指针域；因为n个结点中有n-1个孩子，即2n个指针域中，有n-1个用来指示结点的左右孩子，其余n+1个指针域为空

利用二叉链表中的空指针域：

如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继——这种改变指向的指针称为线索，加上了线索的二叉树称为线索二叉树，增加线索的过程称为线索化

过程：先确定二叉树的遍历顺序，再根据顺序判断前驱后继，如果没有前驱后继则指针仍为空

为了区分lchild和rchild指针是指向孩子的指针还是指向前驱后继的指针，对二叉链表中每个结点曾设两个标志域ltag和rtag，并约定：

- ltag = 0	lchild指向该结点的左孩子
- ltag = 1    lchild 指向该结点的前驱
- rtag = 0    rchild 指向该结点的右孩子
- rtag = 1    rchild指向该结点的后继 



增设一个头节点：

ltag = 0 lchild指向根结点，rtag = 1 rchild指向遍历序列中最后一个结点，遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点

## 树和森林

### 树的存储结构

#### 双亲表示法

实现：定义结构数组存放树的结点，每个结点含两个域

- 数据域：存放结点信息
- 双亲域：指示本结点的父节点在数组中的位置

特点：找父结点容易，找子结点难

#### 孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个节点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储

孩子结点结构：

- child：存放该结点在数组中的位置
- next：指向下一个孩子

父亲结点结构：

- data：数据
- fistchild：指向孩子链表的头指针

特点：找子结点任意，找父节点难

#### 孩子兄弟表示法（二叉树表示法，二叉链表表示法）

用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟节点

### 树与二叉树的转换

通过二叉链表做媒介

#### 将树转换成二叉树

1. 在兄弟之间加一条线
2. 对每个结点，除了其左孩子外，去除其与其余孩子之间的关系
3. 以树的根结点为轴心，将整树顺时针转45°

#### 将二叉树转换成树

1. 若p结点时父节点的左孩子，则将p的右孩子，右孩子的右孩子......沿分支找到所有右孩子，都与p的双亲用线连起来
2. 抹掉原二叉树中父节点与右孩子之间的连线
3. 将结点按层次排列，形成树结构

### 森林与二叉树的转换

#### 森林转换成二叉树

1. 将各棵树分别转换成二叉树
2. 将每棵树的根结点用线相连
3. 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针选择，构成二叉树型结构

#### 二叉树转换成森林

1. 将二叉树中根结点与其右孩子连线及沿右分支搜索到所有右孩子间连线全部抹掉，使之变成孤立的二叉树
2. 将鼓励的二叉树还原成树

### 树与森林的遍历

#### 树的遍历

- 先根（次序）遍历：若树不空，则先访问根节点，然后依次先根遍历各棵子树
- 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点
- 按层次遍历：若树不空，则自上而下自左至右访问数中每个结点

#### 森林的遍历

将森林看作由三部分构成

1. 森林中第一棵树的根结点
2. 森林中第一棵树的子树森林
3. 森林中其它树构成的森林

##### 先序遍历

若森林不空，则

1. 访问森林中第一棵树的根结点
2. 先序遍历森林汇总第一棵树的子树森林
3. 先序遍历森林中（除第一棵树之外）其余树构成的森林

##### 中序遍历

若森林不空，则

1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中第一棵树的根结点
3. 中序遍历森林中（除第一棵子树之外）其余树构成的森林

即：依次从左至右对森林中每一棵树进行后根遍历

## 哈夫曼树（最优二叉树）

判断树：用于描述分类过程的二叉树

路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

结点的路径长度：两结点间路径上的分支数

树的路径长度：从树根到每一个结点的路径长度之和，记作：TL

结点数目相同的二叉树中，完全二叉树是路径最短的二叉树，反之不一定

权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权

结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积

树的带权路径长度：树中所有叶子结点的带权路径之和

哈夫曼树：最优树 即带权路径长度（WPL）最短的树

带权路径长度最短是在度相同的树中比较而得的结果，因此有最优二叉树，最优三叉树等

满二叉树不一定是哈夫曼树；

哈夫曼树中权越大的叶子离根越近；

具有相同带权结点的哈夫曼树不唯一

贪心算法：构造哈夫曼树时首先选择权值小的叶子结点

哈夫曼树的结点度数为0或2，没有度为1的结点

包含n个叶子结点的哈夫曼树中共有2n-1个结点

### 哈夫曼算法（构造哈夫曼树的方法）

1. 根据n个给定的权值构成n棵二叉树的森林，其中每棵树只有一个带权的根结点
   - 构造森林全是根
2. 在森林中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
   - 选用两小造新树
3. 在森林中删除这两棵树，同时将新的二叉树加入森林中
   - 删除两小添新人
4. 重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树

### 哈夫曼树构造算法实现

采用顺序存储结构，即一维结构数组

```c++
typedef struct{
    int weight;
    int parent,lch,rch;
}htnode;




void crateht(htnode ht,int n){
    if(n <= 1) return;
    m = 2*n-1;//数组共2n-1个元素
    ht = new htnode[m+1];
    for(i = 1;i <= m;i ++){
        ht[i].lch = 0;
        ht[i].rch = 0;
        ht[i].parent = 0;
    }
    for(i = 1;i <= n;i ++) 
        cin >> ht[i].weight;
    
    for(i = n + 1;i <= m;i ++){//合并产生n-1个结点
        select(ht,i-1);//在ht[k](1<=k<=i-1)中选择两个其双亲域为0且权值最小的结点，并返回序号s1,s2
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].lch = s1;
        ht[i].rch = s2;
        ht[i].weight = ht[s1].weight + ht[s2].weight
    }
}
```

### 哈夫曼编码

1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）

2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短

3. 在哈夫曼树的每个分支上标上0或1：

   结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码

性质1：哈夫曼编码是前缀码

性质2：哈夫曼编码是最优前缀码

```c++
//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表hc中
void cratehfc(htnode ht,hfc &hc,int n){
    hc = new char*[n+1];//分配n个字符编码的头指针矢量
    cd = new char[n];//临时存放编码的数组
    cd[n-1] = '\0';
    for(i = 1;i <= n;i ++){
        start = n-1;
        c = i;
        f = ht[i].parent;
        while(f != 0){//从叶子开始回溯，直到根结点
            start--;
            if(ht[f].lchild == c) cd[start] = '0';//c是f的左孩子，生成0
            else cd[start] = '1';//c是f的右孩子，生成1
            c = f;
            f = ht[f].parent;
        }
        hc[i] = new char[n-start];
        strcpy(hc[i],&cd[start]);
    }
    delete cd;
}
```

#### 文件的编码和解码

1. 编码
   - 输入各字符及其权值
   - 构造哈夫曼树——ht[i];
   - 进行哈夫曼编码——hc[i];
   - 查hc[i]，得到各字符的哈夫曼编码
2. 解码
   - 构造哈夫曼树
   - 依次读入二进制码
   - 读入0，则走向左孩子；读入1，则走向右孩子
   - 一旦到达某叶子时，即可译出字符
   - 然后再从根出发继续译码，直到结束

# 图

G = (V,E)

V：顶点（数据元素）的有穷非空集合

E：边的有穷集合

无向图：每条边都是无方向的

有向图：每条边都是有方向的

完全图：任意两个点都有一条边相连

无向完全图：n个顶点，n(n-1)/2条边

有向完全图：n个顶点，n(n-1)条边

稀疏图：有很少边或弧的图（e<nlogn）

​				无向称为边，有向称为弧



网：边/弧带权的图



邻接：有边/弧相连的两个顶点之间的关系

​	存在(vi,vj)，则称vi和vj互为邻接点；（无向图，圆括号表示不分先后顺序）

​	存在<vi,vj>，则称vi邻接到vj，vj邻接于vi；（有向图，尖括号表示分先后顺序）



关联（依附）：边/弧与顶点之间的关系

​	存在(vi,vj)/(vi,vj)，则称该边/弧关联于vi和vj



顶点的度：与该顶点相关联的边的数目，即位TD(v)



在有向图中，顶点的度等于该顶点的入度与出度之和

顶点v的入读是以v为终点的有向边的条数，记作ID(v)

顶点v的出度是以v为始点的有向边的条数，记作OD(v)



路径：接续的边构成的顶点序列

路径长度：路径上边或弧的数目/权值之和

回路（环）：第一个顶点和最后一个顶点相同的路径

简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径，即不重复经过

简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径，即绕了一圈



连通图（强连通图）：在无（有）向图G=(V,{E})中，若对任何两个顶点v，u都存在从v到u的路径，则称G是连通图（强连通图）



权与网：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费，带权的图称为网



子图：一个图的边和顶点是另一个图的一部分，则称这个图为另一个图的子图



连通分量（强连通分量）

- 无向图G的极大连通子图称为G的连通分量

  极大连通子图意思是：该子图是G连通子图，将G的任何不在孩子图中的顶点加入，子图不再连通

- 有向图G的极大连通子图称为G的强连通分量



极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通

生成树：包含无向图G所有顶点的极小连通子图

生成森林：对非连通图，由各个连通分量的生成树的集合
## 图的存储结构

### 数组表示法（邻接矩阵）

图没有顺序存储结构，但可以借助二维数组俩表示元素间的关系

- 建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）
- 图的邻接矩阵是一个二维数组，大小为nxn，如果两个顶点之间存在边或弧则记为1，否则记为0 

#### 无向图

- 无向图的邻接矩阵是对称的
- 顶点i的度 = 第i行（列）中1的个数
- 完全图的邻接矩阵中，对角元素为0，其余1

#### 有向图

- 在有向图的邻接矩阵中，第i行表示以结点vi为尾的弧（即出度边），第i列表示以结点vi为头的弧（即入度边）
- 有向图的邻接矩阵可能是不对称的
- 顶点的出度 = 第i行元素之和
- 顶点的出度 = 第i列元素之和
- 顶点的度 = 出度加入度

#### 网

网（即有权图）的邻接矩阵表示，如果两个顶点之间存在边或弧，则在邻接矩阵中记下权值，否则记为无穷大



#### 创建无向网

```c++
#define Maxint 32767

typedef struct{
    char vexs[100];
    int arcs[100][100];
    int vexnum;
    int arcnum;
}Graph;

int createUDN(Graph& G){
    cin>>G.vexnum>>G.arcnum;//输入顶点数，边数
    for(i = 0;i < G.vexnum;i ++)
        cin >> G.vexs[i];//输入点的信息
    for(i = 0;i < G.vexnum;i ++)//初始化邻接矩阵
        for(j = 0;j < G.vexnum;j ++)
            G.arcs[i][j] = Maxint;
    for(k = 0;k < G.arcnum;k ++){
        cin>>v1>>v2>>w;//输入一条边所依附的顶点及边的权值
        i = LocateVex(G,v1);
        j = LocateVex(G,v2);//确定v1和v2在G中的位置
        G.arcs[i][j] = w;
        G.arcs[j][i] = G.arcs[i][j];
    }
    return 0;
}

int LocateVex(Graph G,int u){
    int i;
    for(i = 0;i < G.vexnum;i ++){
        if(u == G.vexs[i]) return i;
    }
    return -1;
}
```

- 由无向网创建无向图
  - 初始化邻接矩阵时，w均为0
  - 构造邻接矩阵时，w为1
- 由无向网创建有向网
  - 邻接矩阵时非对称矩阵
  - 仅为G.arcs[i] [j] 赋值
  - 无需为G.arcs[j] [i]赋值
- 由无向网创建有向图
  - 构造邻接矩阵时，w为1
  - 仅为G.arcs[i] [j] 赋值
  - 无需为G.arcs[j] [i]赋值

### 链式存储结构（邻接表）

多重链表：邻接表，临界多重表，十字链表

- 顶点：
  - 按编号顺序将顶点数据存储在一维数组中
- 关联同一顶点的边（以顶点为尾的弧）
  - 用线性链表存储

顶点放在一维数组中（头结点），每个顶点指向一个结点（表结点），每个结点代表该顶点相连的顶点，内容为数组中对应顶点的下标，结点的后继代表另一个与该顶点相连的顶点

#### 无向图

特点

- 邻接表不唯一
- 若无向图中有n个顶点，e条边，则其邻接表需n个头节点和2e个表结点，适宜存储稀疏图
- 无向图中顶点vi的度为第i个单链表中的结点数

#### 有向图

头节点指向的表结点只有该顶点的出度边所连接的顶点（这种表找出度容易，找入度难）

特点：

- 顶点vi的出度为第i个单链表中的结点个数
- 顶点vi的入度为整个单链表中邻接点域值是i-1的结点个数



如果头节点指向的表结点表示该顶点的入度边所连接的顶点，该表称为逆邻接表（找入度容易，找出度难）

特点

- 顶点vi的入度为第i个单链表中的结点个数
- 顶点vi的出度为整个单链表中邻接点域值是i-1的结点个数

```c++
//邻接表边结点
typedef struct arcnode{
    int adjvex;
    arcnode * nextarc;
}
//邻接表头节点
typedef struct Vnode{
    char data;
    arcnode * firstarc;
}
//图
typedef struct{
    Vnode vertices[max];
    int vexnum;//顶点
    int arcnum;//边
}ALGraph;
```

#### 创建无向网

```c++
int crateUDG(ALGraph& G){
    cin >> G.vexnum >> G.arcnum;//输入顶点数，边数
    for(i = 0;i < G.vexnum;i ++){
        cin >> G.vertices[i].data;//输入顶点值
        G.vertces[i].firstarc = NULL;//初始化
    }
    for(k = 0;k < G.arcnum;k ++){
        cin>>v1>>v2;//输入一条边的两个顶点
        i = LocateVex(G,v1);
        j = LocateVex(G,v2);
        p1 = new arcnode;
        p1->adjvex = j;//邻接点序号为j
        p1->nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;//将新结点*p1插入顶点vi的边表头部
        p2 = new arcnode;
        p2->adjvex = i;
        p2->nextarc = G>vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
    return 0;
}
```

#### 邻接矩阵和邻接表对比

1. 邻接表中每个链表对应于邻接矩阵中的一行，链表汇总结点个数等于一行中非零元素的个数
2. 对于任一确定的无向图，邻接矩阵是唯一的，但邻接表不唯一
3. 邻接矩阵空间复杂度为O(n^2)，邻接表的空间复杂度为O(n+e)
4. 邻接矩阵多用于稠密图，邻接表多用于稀疏图

#### 十字链表

十字链表是有向图的另一种链式存储结构，也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表

有向图中的每一个弧对应十字链表中的一个**弧结点**，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做**顶点结点**

顶点结点由三部分组成，数据域，入度指针域，出度指针域

弧结点由四部分组成，出度的顶点下标，入度的顶点下标，入度指针域，出度指针域

如果该条弧是该顶点的出度弧，则该顶点的出度指针域指向该弧结点，该弧结点的出度指针域指向其它该顶点的出度弧，入度弧反之

#### 邻接多重表

顶点结点有两部分，数据域，指向第一天依附于该顶点的边的指针域

边结点有五部分，标志域（标记此边是否被搜索过），边所连接的两个顶点（ivex，jvex）的下标，一个指针域指向连接ivex的下一条边，一个指针域指向连接jvex的下一条边

## 图的遍历

从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问依次，就叫做图的遍历

图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点

怎么避免重复访问：

设置辅助数组 visited[n]，用来标记每个被访问过的顶点，初始状态visited[i]为0，顶点i被访问，该visited[i]为1，防止被多次访问

### 深度优先遍历（DFS）

- 在访问图中某一起始顶点v后，由v出发，访问它的任一邻接顶点w1
- 再从w1出发，访问与w1邻接但还未被访问过的顶点w2
- 再从w2出发，进行类似的访问
- 如此进行下去，直至到达所有的邻接到达都被访问过的顶点u为止
- 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问过的邻接顶点
- 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问
- 如果没有，就再退回一步进行搜索，直到连通图中所有顶点都被访问过为止

```c++
//用邻接矩阵表示图的深度优先搜索
void DFS(AMGraph G,int v){
    cout<<v;
    visited[v] = 1;
    for(w = 0;w < G.vexnum;w ++){
        if((G.arcs[v][w] != 0) && (!visited[w])) DFS(G,w);
    }
}
```

#### DFS算法效率

- 用邻接矩阵来表示图，时间复杂度为O(n^2)
- 用邻接表来表视图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O(n+e) 

稠密图适于在邻接矩阵上深度遍历

稀疏图适于在邻接表上深度遍历

#### 非连通图的遍历

在一个连通分量访问完后，在未访问的顶点中任取一个，再进行深度搜索

### 广度优先搜索（BFS）

从图的某一结点出发，首先依次分为该结点的所有邻接点vi1，vi2,...vin，再按这些顶点被分为的先后次序依次分为与它们相邻接的所有未被访问的顶点，重复此过程，直到所有顶点被访问为止

#### 非连通图的遍历

在一个连通分量访问完后，在未访问的顶点中任取一个，再进行广度搜索

```c++
//用邻接表表示图的广度优先搜索
void BFS(Graph G,int v){
    cout<<v;
    visited[v] = 1;
    InitQueue(Q);//初始化队列
    EnQueue(Q,v);//v进队
    while(!QueueEmpty(Q)){//队列非空
        DeQueue(Q,u);//队头元素出队并置为u
        for(w = FirstAdjVex(G,u);w >= 0;w = NextAdjVex(G,u,w))
            if(!visited[w]){//w2为u的尚未访问的邻接顶点
                cout<<w;
                visited[w] = 1;
                EnQueue(Q,w);//w进队
            }
    }
}
```

#### BFS算法效率

- 如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素），总的时间代价为O(n^2)
- 用邻接表来表视图，虽然有2e个表结点，但只需扫描e个结点，加上访问n个头结点的时间，时间复杂度为O(n+e)

### DFS与BFS对比

- 空间复杂度相同，都是O(n)
- 时间复杂度只与存储结构有关，而与搜索路径无关

## 最小生成树

生成树：所有顶点均由边连接在一起，但不存在回路的图

- 一个图可以有许多棵不同的生成树
- 所有生成树具有以下共同特点
  - 生成树的顶点个数与图的顶点个数相同
  - 生成树是图的极小连通子图，去掉一条边则非连通
  - 一个有n个顶点的连通图的生成树有n-1条边
  - 在生成树中再加一条边必然形成回路
  - 生成树中任意两个顶点间的路径是唯一的
- 含n个顶点n-1条边的图不一定是生成树

最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树

### 构造最小生成树Minimum Spanning Tree

最小生成树可能不唯一

构造最小生成树的算法很多，其中多数算法都利用了MST性质

MST性质：设N = (V,E)是一个连通网，U是顶点集V的一个非空子集，若边（u,v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必存在一棵包含边（u,v）的最小生成树（构造最小生成树要包含一条权值最小的边）

- 已落在生成树上的顶点集：U
- 尚未落在生成树上的顶点集：V-U

接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边

#### 普里姆（Prim）算法

- 设N = (V,E)是连通网，TE是N上最小生成树中边的集合
- 初始令U = {u0},(u0属于V)，TE={  }
- 在所有u属于U，v属于V-U的边（u，v)属于E中，找一条代价最小的边（u0，v0）
- 将（u0，v0）并入集合TE，同时v0并入U
- 重复上述操作直至U=V为止，则T=（V，TE）为N的最小生成树

先找一个顶点归入U，再找一条和该顶点相连权值最小的边的顶点归入U，每次在U中的顶点和U之外的顶点中找权值最小的边，然后将这条边连起来的顶点加入U

时间复杂度O(n^2)，适用稠密图

#### 克鲁斯卡尔（Kruskal）算法

- 设连通网N=（V，E），令最小生成树初始状态只有n个顶点而无边的非连通图T=（V，{  }），每个顶点自成一个连通分量
- 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上（即：不能形成环），则将此边加入到T中；否则，舍去此边，选取下一条代价最小的边
- 依次类推，直至T中所有顶点都在同一连通分量上为止

先把所有顶点独立出来，然后从所有边中选取权值最小的边，但是不能形成回路，直到所有顶点被连接起来

时间复杂度O(eloge)  （e为边数）  ，适用稀疏图

## 最短路径

两种常见的最短路径问题：

1. 单源最短路径——用Dijkstra（迪杰斯特拉）算法
2. 所有顶点间的最短路径——用Floyd（佛洛依德）算法

### Dijkstra算法

1. 初始化：先找出从源点v0到各终点vk的直达路径（v0，vk），即通过一条弧到达的路径

2. 选择：从这些路径中找出一条长度最短的路径（v0，u）

3. 更新：然后对其余各条路径进行适当调整：

   若在图中存在弧（u，vk），且（v0，u）+（u，vk）<(v0，vk)，则以路径（v0，u，vk）代替（v0，vk）

   在调整后的各条路径中，再找长度最短的路径，依此类推

初始时令S = {v0}，T={其余顶点}，T中顶点对应的距离值用辅助数组D存放，D[i]初值：若<v0,vi>存在（就是从v0能到达vi），则为其权值，否则为无穷大。从T中选取一个其距离值最小的顶点vj加入S，对T中顶点的距离值进行修改：若加进vj作中间顶点，从v0到vi的距离值比不加vj的路径要短，则修改此距离值，重复上述步骤，直到S = V为止

### Floyd算法

求所有顶点间的最短路径

1. 每次以一个顶点为源点，重复执行Dijkstra算法n次
2. Floyd算法

算法思想：

- 逐个顶点试探
- 从vi到vj的所有可能存在的路径中
- 选出一条长度最短的路径

求最短路径步骤

1. 初始时设置一个n阶方阵，令其对角线元素为0，若存在弧<vi,vj>，则对应元素为权值，否则为无穷大
2. 逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值，所有顶点试探完毕，算法结束

## 有向无环图

有向无环图：无环的有向图，简称DAG图

有向无环图的应用

- AOV网：拓扑排序

  用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的优先制约关系，称着中国有向图为顶点表示活动的网

  - 若i到j有一条有向路径，则i是j的前驱，j是i的后继
  - 若i和j相邻，则称为直接前驱，直接后继
  - AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，这显然是荒谬的

- AOE网：关键路径

  用一个有向图表示一个工程的各子工程及其相互制约的关系，以弧表示活动，以顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网

## 拓扑排序

在AOV网没有回路的前提下，我们将活动排列成一个线性序列，使得若AOV网中有弧<i，j>存在（i是j的直接前驱），则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序序列的算法称为拓扑排序

1. 在有向图中选一个没有前驱的顶点且输出
2. 从图中删除该顶点和所有以它为尾的弧
3. 重复上述两步，直至全部顶点均已输出，或者当图中不存在无前驱的顶点为止

一个AOV网的拓扑有序列不是唯一的

检测AOV网中是否存在环：

对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环

## 关键路径

把工程计划表示为边表示活动的网络，即AOE网，**用顶点表示事件，弧表示活动**，弧的权表示活动持续时间

ve(vj)：表示时间vj的最早发生时间

vl(vj)：表示时间vj的最迟发生时间

e(i)：表示活动ai的最早发生时间

l(i)：表示活动ai的最迟开始时间

l(i) - e(i)：表示完成活动ai的时间余量

关键活动：关键路径上的活动，即l(i) == e(i)的活动

设活动ai用弧<j,k>表示，其持续时间为：wj,k

则有：

1. e(i) = ve(j)    i为弧的编号，j为发出弧的顶点的编号
2. l(i) = vl(k) - wj,k  i为弧的编号，j为弧头，k为弧尾

如何求ve(j) 和 vl(j)：

1. 从ve(1) = 0开始往后递推

   ve(j) = max{ve(i) + wi,j},<i,j>属于 T，2<= j <= n，其中T是所有以j为头的弧的集合

   该顶点的最早发生时间为弧线指向它的顶点的最早发生时间加上弧线的权值，在多条弧线中选择最大的值

2. 从vl(n) = ve(n) 开始往前递推 vl(i) = min{vl(j) - wi,j}，<i,j>属于 S，1 <= i <= n -1，其中S是所有以i为尾的弧的集合

   该顶点的最晚发生时间为它发出的弧线指向的顶点的最晚发生时间减去弧线的权值，在多条弧线中选择最小的值

**关键路径讨论**

1. 如果网中有几条关键路径，则需加快同时在几条关键路径上的关键活动
2. 如果一个活动位于所有的关键路径上，加快这个活动的速度，就能缩短整个工程的完成时间
3. 处于所有关键路径上的活动时间不能缩短太多，否则会使原来的关键路径变成不是关键路径，此时必须重新寻找关键路径

# 查找

- 静态查找表：仅作“查询”
- 动态查找表：作“插入”和“删除”的查找表

查找算法的评价指标：关键字的评价比较次数，也称平均查找长度ASL

ASL等于每个元素查询的次数除以元素个数

## 线性表的查找

### 顺序查找（线性查找）

应用范围：

- 顺序表或线性链表示的静态查找表
- 表内元素之间无序

```c++
typedef struct{
    ktype key;
    ...
}ElemType;

typedef struct{
    ElemType* R;//表基址
    int length;//表长
}SSTable;

SSTable ST;

int searcg(SSTable ST,ktype key){
    for(i = ST.length;i >= 1;i --)
        if(ST.R[i].key == key) return i;
    return 0;
}
```

改进：把待查关键字key存入表头（哨兵，监视哨），从后往前逐个比较，可免去查找过程中每一步都要检测十分偶查找完毕，加快速度

```c++
int searcg(SSTable ST,ktype key){
    ST.R[0].key = key;
    for(i = ST.length;ST.R[0] != key;i --);
    return i;
}
```

时间效率分析：

比较次数与key的位置有关

- 查找第i各元素，要比较n - i + 1次
- 查找失败，要比较n + 1次

ASL(n) = （1+2+...+n）/2=（n+1）/2

时间复杂度O(n)  空间复杂度O(1)

1. 按照查找概率高低存储
2. 记录的查找概率无法测定时怎么办
   - 在每个记录中设一个访问频度域
   - 始终保持记录按非递增有序的次序排列
   - 每次查找后均将刚查找到的记录直接移至表头

### 二分查找

只限于顺序存储结构，对线性链表无效

每次将待查找记录所在区间缩小一半

```c++
while(high >= low){
    mid = (low + high) / 2;
    if(key < arr[mid]) high = mid - 1;
    else if(key > arr[mid]) low = mid + 1;
    else return mid;
}
if(high < low) return 0;


//递归
int search(int low,int high);

if(low > high) return 0;
mid = (low + high) / 2;
if(key == arr[mid]) return mid;
else if(key < arr[mid]) search(low,mid-1);
else search(mid+1,high);
```

性能分析：

平均查找长度：log2(n+1)-1

设表长n = 2^h -1，则h=log2(n+1) 此时判定树为深度为h的满二叉树

### 分块查找（索引查找）

1. 将表分成几块，且表有序或者分块有序   若 i < j，则第j块中所有记录的关键案子均大于第i块中的最大关键字
2. 建立“索引表”（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）
3. 查找过程：先确定待查找记录所在块，再在块内查找

查找效率：ASL = Lb + Lw（对索引查找的ASL加上块内查找的ASL）

ASL约等于 log2(n/s + 1)   +  s/2

s为每块内部的记录个数  n/s即块的数目

## 树表的查找

当表插入，删除操作频繁时，改用动态查找表——几种特殊的树（二叉排序树，平衡二叉树，红黑树，B-树，B+树，键树）

表结构在查找过程中动态生成，对于给定key，若表中存在，则成功返回，否则，插入关键字等于key的记录

### 二叉排序树

又称二叉搜索树，二叉查找树

二叉排序树或是空树，或是满足如下性质的二叉树：

1. 若是左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值
3. 其左右子树本身又各是一棵二叉排序树

中序遍历非空的二叉排序树所得到的数据元素是一个按关键字排列的递增有序序列

#### 查找

若查找的关键字等于根结点，成功

否则

- 若小于根结点，查找左子树
- 若大于根结点，查找右子树

重复

```c++
typedef struct{
    ktype key;//关键字
    infotype other;//其它数据域
}ElemType;


typedef struct BSTNode{
    ElemType data;
    struct BSTNode* lchild,* rchld;
}

BSTNode* T;


BSTNode* search(BSNode* T,ktype key){
    if(!T || key == T->data.key) return T;
    else if(key < T->data.key) return search(T->lchild,key);
    else return search(T->rchild,key);
}
```

1. 若二叉排序树为空，则查找失败，返回空指针
2. 若二叉排序树非空，将key与根结点的关键字T->data.key比较
   - 若key等于data.key，则查找成功，返回根结点地址
   - 若小于，进一步查找左子树
   - 若大于，进一步查找右子树

算法效率分析：

含有n个结点的二叉排序树的平均查找长度和树的形态有关

最好情况：O(log2n)

最坏情况：O(n)

如何提高形态不均衡的二叉排序树的查找效率：做“平衡化”处理，尽量让二叉树的形态均衡

#### 插入

- 若二叉排序树为空，则插入结点作为根结点插入到空树中
- 否则，继续在其左，右子树上查找
  - 树中已有，不再插入
  - 树中没有
    - 查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子

#### 生成

从空树出发，经过一系列的查找，插入操作之后，可生成一棵二叉排序树

一个无序序列可通过构造二叉排序树而变成一个有序序列，构造树的过程就是对无序序列进行排序的过程

插入的结点均为叶子节点，故无需移动其他结点，相当于在有序序列上插入记录而无需移动其他记录

但是：关键字的输入顺序不同，建立的二叉排序树不同

#### 删除

从二叉排序树中删除一个结点，不能把以该节点为根的子树都删去，只能删除掉该结点，并且还应保证删除后所得的二叉排序树仍然满足二叉排序树的性质不变

- 将因删除结点而断开的二叉链表重新连接起来
- 防止重新连接后树的高度增加

1. 被删除的结点是叶子结点，直接删去该结点
2. 被删除的结点只有左子树或只有右子树，用左子树或右子树替换它，其父节点的指针域改为指向被删除结点的左子树或右子树
3. 被删除的结点既有左子树又有右子树
   - 以其中序遍历的前驱结点替换它，然后再删除该前驱结点，前驱是左子树中最大的结点
   - 也可以用其后继结点替换，然后删除该后继结点，后继是右子树中最小的结点

### 平衡二叉树

- 又称AVL树
- 一棵平衡二叉树或者是空树，或者是具有以下性质的二叉排序树
  - 左子树与右子树的高度之差的绝对值小于等于1
  - 左子树和右子树也是平衡二叉排序树

为了方便，给每个结点附加一个数字，给出该结点左子树与右子树的高度差，这个数字称为结点的平衡因子（BF）

平衡因子 = 结点左子树的高度 - 结点右子树的高度

平衡二叉树上所有结点的平衡因子只能是-1，0，1

对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级



如果在一棵AVL树中插入了一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡

平衡调整的四种类型：

A：失衡结点，不止一个失衡结点时，为最小失衡子树的根结点

B：A结点的孩子，C结点的父亲

C：插入新结点的子树

LL型，LR型，RL型，RR型

LL表示A为根结点，B为A的左子树，C为B的左子树，R同理

调整：

1. 降低高度
2. 保持二叉排序树性质，即保证左子树比右子树小，大小排第二的放到根结点

LL型调整：调整后B结点的右子树成为A结点的左子树

RR型调整：调整后B的左子树成为A的右子树

LR型调整：调整后C的左子树成为B的右子树，C的右子树成为B的左子树

RL型调整：调整后C的左子树成为A的右子树，C的右子树成为B的左子树

## 散列表的查找

基本思想：记录的存储位置与关键字之间存在对应关系

对应关系：hash函数

Loc(i) = H(keyi)

查找效率高，空间效率低

#### 散列表术语

散列方法（杂凑法）：

选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址中元素关键码进行对比，确定查找是否成功

散列函数（杂凑函数）：散列方法中使用的转换函数

散列表（杂凑表）：用上述思想构造的表

冲突：不同的关键码映射到同一个散列地址

同义词：具有相同函数值的多个关键字

#### 散列函数的构造方法

根据元素集合的特性构造

- n个数据仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小
- 无论用扫描方法存储，目的都是尽量均匀地存放元素，以避免冲突

##### 直接定址法

Hash(key) = a·key + b (a，b为常数)

空间效率低，不会产生冲突

##### 除留余法

Hash(key) = key mod p

#### 处理冲突的方法

##### 开放地址法

有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入

#### 链地址法（拉链法）

相同的散列地址的记录链成一单链表，m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构

冲突时计算key的下一个存储地址，若该地址对应的链表不为空，则利用链表的前叉法或后插法将该元素插入此链表

### 查找

给定k值，计算H(k)，地址为空查找失败，找到元素查找成功，出现冲突解决冲突

ASL取决于

- 散列函数
- 处理冲突的方法
- 散列表的装填因子α

α = 表中装填的记录数/散列表长度

# 排序

排序的稳定性只对结构数据类型排序有意义

稳定性是指前后两个相同大小的元素在排完序后相对位置是否发生了改变，改变了则为不稳定排序

自然排序是指输入的数据越有序速度越快

## 插入排序

每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止

### 直接插入排序

```c++
t = a[i];//复制元素
for(j = i - 1;j >= 0 && t < a[j];j --)//后移
    a[j + 1] = a[j];
a[j + 1] = t;//插入


//使用哨兵
for(i = 2;i <= a.length;i ++){
    if(a[i]  < a[i - 1]){
        a[0] = a[i];
        for(j = i - 1;a[0] < a[j];j --){
            a[j + 1] = a[j];
        }            
        a[j + 1] = a[0];
    }
}


```

时间复杂度最好O(n)，最坏O(n^2)，平均O(n^2)

### 二分插入排序

```c++
for(i = 2;i <= len;i ++){
    a[0] = a[i];
    low = 1;
    high = i - 1;
    while(low <= high){
        mid = (low + high)/2;
        if(a[0] < a[mid]) high = mid - 1;
        else low = mid + 1;
    }
    for(j = i - 1;i >= high + 1;j --)
        a[j + 1] = a[j];
    a[high + 1] = a[0];
}
```

当n较大时，二分排序比直接排序更快

当初始数据越有序时，直接排序更快

时间复杂度O(n^2)

### 希尔排序

先将整个待排记录序列分割成若干个子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序

- 一次移动，移动位置较大，跳跃式的接近排序后的最终位置
- 最后一次只需要少量移动
- 增量排序必须是递减的，最后一个是1
- 增量排序应该是互质的

```c++
void shellsort(int arr[],int len){
    int gap,i,j;
    int t;
    for(gap = len >> 1;gap > 0;gap >>= 1){
        for(i = gap;i < len;i ++){
            t = arr[i];
            for(j = i - gap;j >= 0 && arr[j] > t;j -= gap){
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = t;
        }
    }
}
```

希尔排序是不稳定排序

时间复杂度O(n^1.25)~O(1.6n^1.25)——经验公式

## 交换排序

### 冒泡排序

```c++
void bublesort(int a[],int len){
    for(int i = 0;i < len-1;i ++){
        for(j = i + 1;j < len - i;j ++){
            if(a[i] > a[j]){
                int t = a[j];
                a[j] = a[i];
                a[i] = t;
            }
        }
    }
}
```

冒泡排序是稳定排序

### 快速排序

任取一个元素为中心，所有比它小的元素一律前放，比它大的元素一律后放

```c++
void quicksort(int a[],int l,int r){
    if(l > r) return;
    int i,j,t,x;
    x = a[l];
    i = l;
    j = r;
    while(i != j){
       while(j >= x && i < j){
        	j --;
    	}
    	while(i <= x && i < j){
        	i ++;
   		}
        if(i < j){
            t = a[j];
            a[j] = a[i];
            a[i] = t;
        }
    }
    a[l] = a[i];
    a[i] = x;
    quicksort(a,l,i-1);
    quicksort(a,i+1,r);
}
```

时间复杂度O(nlog2n)

快速排序是不稳定排序

## 选择排序

### 简单选择排序

在待排序的数据中选择出最大（小）的元素放在其最终的位置

```c++
void selectsort(int a[],int len){
    int i,j,min;
    for(i = 0;i < len - 1;i ++){
        min = i;
        for(j = i + 1;j < len;j ++){
            if(a[min] > a[j]){
                min = j
            }
        }
        int t = a[i];
        a[i] = a[min];
        a[min] = t;
    }
}
```

不稳定排序

时间复杂度O(n^2)

### 堆排序

堆的定义：

若n个元素的序列{a1,a2,...an}满足

(ai <= a2i  ,  ai <= a(2i+1))或(ai >= a2i  ,  ai >= a(2i+1))

则分别称该序列为小根堆和大根堆

堆是一棵完全二叉树，如果每个结点都大于等于子节点的值，为最大堆，反之为最小堆

堆用数组存储时按照从上到下从左到右的顺序写在数组里



每次输出堆顶的最大（最小）值后，使得剩余的n-1个元素重新建成一个堆，这个过程称之为堆排序

**如何在输出堆顶元素后，调整剩余元素为一个新的堆**

最小堆：

1. 输出堆顶元素之后，以堆中最后一个元素代替之
2. 将根结点值与左右子树的根结点的值进行比较，并与其中小者进行交换
3. 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程称之为筛选

```c++
//数组从0开始
void heap(int a[],int start,int end){
    int dad = start;
    int son = start * 2 + 1;
    while(son <= end){
        if(son + 1 <= end && a[son] < a[son + 1])
            son ++;//让较大的子节点为son
        if(a[dad] > a[son])
            break;
        else{
            int t = a[son];//交换父子结点
            a[son] = a[dad];
            a[dad] = t;
            dad = son;//这步是调整堆时的，将堆顶的元素置于最后一位后，将此时的堆顶元素一步一步降下去
            son = son * 2 + 1;
        }
    }
}

void heapsort(int a[],int len){
    int i;
    for(i = len/2 - 1;i >= 0;i --){//从最后一个根结点开始判断，倒着来，让最大的元素上去
        heap(a,i,len - 1);//这个循环时将初始时的无序的二叉树，也就是堆，变成最大堆，让最大的元素置于顶部
    }
    for(i = len - 1;i > 0;i --){//此时i指向无序的最后一个元素
        int t = a[i];
        a[i] = a[0];
        a[0] = t;//将第一个元素也就是最大的元素与最后一个无序元素交换，此时i指向第一个有序元素
        heap(a,0,i - 1);//从第一个元素也就是最小的元素开始，正着往后判断，将这个最小的元素降下去，此时i指向第一个有序元素，所以end为i的前一个元素
    }
}
```

时间复杂度O(nlogn)

## 归并排序

将两个或两个以上的有序子序列归并为一个有序序列，通常采用2路归并排序，即将两个相邻的子序列归并为一个有序的子序列

