# 线性表

## 线性表的链式表示

### 头指针，头节点，首元节点

头指针：指向链表中第一个节点的指针

首元节点：指链表中存储第一个元素的节点

头节点：在链表的首元节点之前附设的一个节点

### 如何表示空表

无头节点时，头指针为空表示空表

有头节点时，头节点的指针域为空表示空表

### 链表中设置头节点的好处

1. 便于首元节点的处理，首元节点的地址保存在头节点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理
2. 便于空表和非空表 的统一处理，无论链表是否为空，头指针都是指向头节点的非空指针，因此空表和非空表的处理也就统一了

### 头节点的数据域

可以为空，也可以存放线性表长度等附加信息，但此节点不计入链表长度

### 链表（链式存储结构） 的特点

1. 节点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
2. 访问时只能通过头指针进入链表，并通过每个节点的指针域一次向后顺序扫描其余节点，所以寻找第一个节点和最后一个节点所花的时间不等，这种存取元素的方法被称为顺序存取法

### 单链表

#### 单链表销毁

```c++
Lnode *p;
while(head!=NULL){
    p = head;
    head = head->next;
    delete p;
}
```

#### 单链表清空

链表仍存在，但链表中无元素，成为空链表（头指针和头节点仍然在）

```c++
Lnode *p;
Lnode *q;
p = head->next;
while(p!=NULL){
    q = p->next;
    delete p;
	p = q;
}
head->next = NULL;//头节点置为空
```

#### 单链表求表长

```c++
Lnode *p;
p = head->next;
int i = 0;
while(p!=NULL){
    i ++;
    p = p->next;
}
```

#### 单链表取值

```c++
Lnode *p;
p = head->next;
int j = 1;
while(p!= NULL && j < i){
    p = p->next;
    j ++;
}
//此时查询的数据为p所指的节点的data域
```

#### 单链表查找

按值查找

```c++
Lnode *p;
p = head->next;
while(p!=NULL && p->data!=e){
    p = p->next;
}
//可以return地址p或位置序号
```

#### 单链表插入

```c++
Lnode *p;
p = head;
j = 0;
while(p!=NULL && j < i - 1){
	p = p->next;
    j ++;
}
s = new Lnode;
s->data = e;
s->next = p->next;
p->next = s;
```

#### 单链表删除

```c++
Lnode *p;
Lnode *q;
p = head;
j = 0;
while(p->next && j < i - 1){
    p = p->next;
    j ++;
}
q = p->next;
p->next = q->next;
e = q->data;
delete q;
```

#### 单链表创建

##### 前插法

1. 从一个空表开始，重复读入数据
2. 生成新节点，将读入数据存放到新节点的数据域中
3. 从最后一个节点开始，依次将各节点插入到链表的前端

```c++
L = new Lnode;
L->next = NULL;
for(i = n;i > 0;i --){
    p = new Lnode;
    cin>>p->data;
    p->next = L->next;
    L->next = p;
}
```

##### 后插法

1. 从一个空表L开始，将新节点逐个插入到链表的尾部，尾指针r指向链表的尾节点
2. 初始时，r和L均指向头节点，每读入一个数据元素则申请一个新节点，将新节点插入到尾节点后，r指向新节点

```c++
L = new Lnode;
Lnode *r;
L->next = NULL;
r = L;
int i;
for(i = 0;i < n;i ++){
    p = new Lnode;
    cin>>p->data;
    p->next = NULL;
    r->next = p;
    r = p;
}
```

#### 循环链表

是一种头尾相接的链表，即表中最后一个节点的指针域指向头节点，整个链表形成一个环

优点：从表中任一节点出发均可找到表中其它节点

头节点的指针域存放头指针，即指向自己

注意：由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件为判断它们是否等于头指针

由于表的操作常常在表的首尾位置上进行，所以可以使用尾指针表示单循环链表，首元节点为r->next->next，尾节点为r

##### 带尾指针循环链表的合并

```c++
Lnode *p;
p = Ra->next;
Ra->next = Rb->next->next;
delete Rb->next;
Rb->next = p;
```

### 双向链表

相较于单链表多了一个prior指针指向节点前趋

双向链表的头节点的prior为空，尾节点next为空

空表的头节点的prior和next都为空

#### 双循环链表

1. 让头节点的prior指向链表的尾节点
2. 让尾节点的next指向头节点

双向链表的对称性：`p->prior->next = p = p->next->prior`

#### 双向链表插入

```c++
s = new Dnode;
s->data = e;
s->prior = p->prior;
p->prior->next = s;
s->next = p;
p->prior = s;
```

#### 双向链表删除

```c++
p->prior->next = p->next;
p->next->prior = p->prior;
delete p;
```

### 顺序表和链表的比较

- 链式存储结构的优点

  - 结点空间可以动态申请和释放
  - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要一定数据元素

- 链式存储结构的缺点

  - 存储密度小，每个结点的指针域需额外占用存储空间，当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大

    存储密度 = 结点数据本身占用的空间/结点占用的空间总量

  - 链式存储结构是非随机存储结构，对任一结点的操作都要从头指针依指针链查找到该结点，增加了算法的复杂度

顺序表适用情况：

1. 表长变化不大，且能事先确定变化的范围
2. 很少进行插入或删除操作，教程按元素位置序号访问数据元素

链表适用情况：

1. 长度变化较大
2. 频繁进行插入或删除操作

## 线性表的应用

### 线性表的合并

将两个线性表a,b合并，求新表aUb

思路：遍历线性表b中每个元素，查询a表中是否有该元素，如果没有，则插入a表

### 有序表的合并

将两个有序线性表合并，要求合并后的新表仍然有序

思路：

1. 创建一个空表c
2. 依次从a或b中选择元素值较小的结点插入c表的最后，直至其中一个表为空为止
3. 继续将a或b其中一个表的剩余结点插入在c表的最后

# 栈和队列

栈和队列是限定插入和删除只能在表的“端点”进行的线性表

## 栈

限定只能在表的一端进行插入和删除运算的线性表（只能在栈顶操作）

栈先进后出，后进先出（LIFO结构）

如果问题求解的过程具有后进先出的特性的话，求解的算法中必然需要利用栈

如：

- 数制转换
- 表达式求值
- 括号匹配检验
- 八皇后问题
- 行编辑程序
- 函数调用
- 迷宫求解
- 递归调用的实现

### 顺序栈

利用一组地址连续存储单元依次存放自栈底到栈顶的数元素，栈底一般在低地址端

- 另附top指针，指示栈顶元素在顺序栈中的位置
- 另附base指针，只是栈底元素在顺序栈中的位置
- 但是，为了方便操作，通常top指示真正的栈顶元素之上的下标地址
- base == top 是空栈标志
- top - base == stacksize 是满栈标志

### 链栈

链栈是运算受限的单链表，只能在链表头部进行操作

- 链表的头指针就是栈顶
- 不需要头节点
- 基本不存在栈满的情况
- 空栈相当于头指针指向空
- 插入和删除仅在栈顶处执行

### 栈与递归

- 具有递归特性的数据结构
  - 二叉树
  - 广义表



## 队列

队列是一种先进先出（FIFO）的线性表，在表一端插入（表尾），在另一端（表头）删除

- 脱机打印输出：按申请的先后顺序依次输出
- 多用户系统中，多个用户排成队，分时的循环使用CPU和主存
- 按用户的优先级排成多个队，每个优先级一个队列
- 实时控制系统中，信号按接受的先后顺序依次处理
- 网络电文传输，按到达的时间先后顺序依次进行

### 顺序队列

顺序队列有两个指针front和rear

入队时rear++

出队时front++

顺序队列存在假溢出情况，即rear指向末尾，但队列前端为空。

解决方法：将队列想像成一个循环的表，当rear指向maxsize时，如果队列前端为空，则rear执行队列前端，当front为maxsize时同样

指针移动：`rear = (rear + 1) % maxsize`

判断队满：`(rear + 1) % maxsize == fron`   解释：少用一个空间，当尾指针追上头指针时队满

求队列长度：`(rear - front  + maxsize) % maxsize`

### 链队

设置头指针，头节点，尾指针

出队时直接将头节点指向首元结点的下一结点

入队时让尾指针的下一节点指向新结点

## 栈和队列案例

### 进制转换

- 十进制整数向其它进制数转换

转换法则：除以d（进制数）倒取余

即：将十进制数不断除以d，直到余数为0，将余数倒着列出来即为转换后的数

### 表达式求值

- 设置两个栈，运算符栈op，操作数栈num

- 从左至右扫描每一个字符，扫描到的是运算数则压入num，扫描到运算符时：
  - 若这个运算符比op栈顶运算符的优先级高，则入栈op
  - 若这个运算符比op栈顶运算符优先级低或同等，则弹出op栈顶运算符，弹出两个操作数，计算后压入栈num
  - 如果运算符为（  则压入op，如果为  ）则使用op栈顶运算符运算，直到栈顶为（
- 继续向后扫描，直到遇到结束符

# 串，数组，广义表

## 串

**子串：**一个串中任意个连续字符组成的子序列（含空串）称为改串的子串

**真子串：**不包含自身的所有子串

**字符位置：**字符在序列中的序号

**子串位置：**子 串第一个字符在主串中的位置

**空格串：**由一个或多个空格组成的串，与空串不同

**串相等：**当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，两个串才相等

### 字符串匹配

算法目的：确定主串中所含子串第一次出现的位置（定位）

算法种类：

- BF算法（暴力）
- KMP算法

#### BF算法

思路：从主串的每一个字符开始依次与字串的字符进行匹配

设i为主串计数器，j为字串计数器，出现匹配失败后:

`i = i - j + 1;`

`j = 0;`

```c++
//核心代码
int i = 0;
int j = 0;
while(i < S.length && j < T.length){
    if(S[i] == T[j]){
        i ++;
        j ++;
    }else{
        i = i - j + 1;
        j = 0;
    }
}
if(j >= T.length) return i - j;
if(i >= S.length) return -1;
```

#### KMP算法

定义next[j]数组，当子串中第j个字符与主串失配时，在子串中需重新和主串中改字符进行比较的字符的位置

失配时，观察此时j的左边，找到最长公共前缀，公共后缀，最长公共前后缀小于左边的子串长度

若子串下标从1开始，则下一次主串失配字符 与子串最长公共前后缀的长度+1上的字符比较

若子串下标从0开始，则下一次主串失配字符与子串最长公共前后缀的长度上的字符比较

若失配字符左边无公共前缀后缀，则下一次主串失配字符与子串第一个字符比较，如果子串下标从1开始，那么此时next[j]中存入0，下次循环i++,j++

若主串第一个字符与子串第一个字符不等，则下一次由主串下一个元素比较

```c++
int i = 1;
int j = 1;
while(i <= s.length && j <= t.length){
    if(j == 0 || s[i] == t[j]){
        i ++;
        j ++;
    }else j = next[j];
}
```

```c++
//求next数组 细细品
int i = 1;
next[1] = 0;
int j = 0;
while(i < t.length){
    if(j == 0 || t[i] == t[j]){
        i ++;
        j ++;
        next[i] = j;
    }else j = next[j];
}
```

## 数组

### 矩阵压缩

没记笔记，考到再说，我觉得用处不大

## 广义表

广义表通常记作：LS = (a1,a2,······,an)

广义表每个元素可以类型不同，元素也可以为广义表，元素为广义表时带括号，大写字母代表广义表，小写字母代表原子

1. 广义表中的数据元素有相对次序。一个直接前驱，一个直接后驱
2. 广义表的长度定义为最外层所包含元素的个数
3. 广义表的深度定义为改广义表展开后所含括号的层数
4. 广义表可以为其它广义表共享
5. 广义表可以是一个递归的表，此时深度为无穷
6. 广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素也可以是子表

# 树

## 树的定义

树（Tree）是n（n>=0）个结点的有限集

若n = 0，称为空树

若n > 0，则它满足如下两个条件：

1. 有且仅有一个特点的称为根（Root）的结点；
2. 其余结点可分为m（m>=0）个互不相交的有限集T1，T2，T3，...，Tm，其中每一个集合本身又是一棵树，并称为根的子树



根结点：非空树无前驱结点的结点

结点的度：结点所拥有的子树数

树的度：树内各结点的度的最大值

度为0：称为叶子，为终端结点

结点的子树的根称为该结点的孩子，该结点称为孩子的父亲

结点的祖先：从根到该结点所经分支上的所有结点

结点的子孙：以某结点为根的子树中的任一结点

树的深度：树中结点的最大层次

有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子），反正称为无序树

森林：是m(m>= 0)棵互不相交的树的集合，把根结点删除树就变成了森林，一棵树可以看成一个特殊的森林

## 二叉树

每个结点最多有两个孩子

子树有左右之分，次序不能颠倒

二叉树可以是空集合，根可以有空的左子树或空的右子树

二叉树结点的字数要区分左子树和右子树，只有一棵子树也要区分它是左子树还是右子树，树只有一棵子树时不需要区分

### 二叉树的性质

1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1) ,最少有1个

2. 深度为k二叉树至多有2^k - 1个结点（k>=1)，最少有k个

3. 队任何一棵二叉树T，如果其叶子数为n0，度为2的结点数为n2，则n0 = n2 + 1

4. 具有n个结点的完全二叉树的深度为[log2 n]+1  

   [ x]意思是不大于x的最大整数

5. 如果对一棵有n个结点的完全二叉树（深度为[log2 n] + 1）的结点按层序编号（从第1层到第[log2 n] + 1层，每层从左到右），则对任一结点i（i<=i<=n），有

   - 如果i = 1，则结点i是二叉树的根，无父亲；如果i > 1，则其父亲是结点[i/2]
   - 如果2i > n，则结点i为叶子节点，无左孩子；否则，其左孩子是节点2i
   - 如果2i + 1 > n，则节点i无右孩子；否则，其右孩子是结点2i + 1

### 满二叉树

一棵深度为k且有2^k - 1个结点的二叉树称为满二叉树

特点：

1. 每一层上的结点数都是最大结点数
2. 叶子结点全部在最底层

编号时从根结点开始从上到下，从左到右

### 完全二叉树

深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称之为完全二叉树

主要看编号和二叉树是不是一一对应的。

在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树

### 二叉树的存储结构

#### 二叉树的顺序存储

实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素

顺序存储缺点：最快情况下浪费空间，深度为k的且之有k个结点的单支树需要长度为2^k - 1 的一维数组

顺序存储适合满二叉树和完全二叉树

#### 二叉树的链式存储结构

每个结点有一个data域，两个指针域

在n个结点的二叉链表中，有n + 1 个空指针域

三叉链表：再增加一个指针域，指向它的前驱

### 遍历二叉树

顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次

遍历顺序：DLR 先（根）序遍历，LDR 中（根）序遍历，LRD 后（根）序遍历，递归调用

根据遍历顺序求二叉树，必须有中序，可以为先序和中序或后序和中序，前序的第一个一定为根结点，后序的最后一个一定为根结点

```c++
//先序遍历
void pre(BTree *p){
    if(p != NULL){
        cout<<t->data<<endl;
        pre(p->lchild);
        pre(p->rchild);
    }
}

//中序遍历
void pre(BTree *p){
    if(p != NULL){
        pre(p->lchild);
        cout<<p->data<<endl;
        pre(p->rchild);
    }
}
```

#### 中序遍历非递归算法

1. 建立一个栈
2. 根结点进栈，遍历左子树
3. 根结点出栈，输出根结点，遍历右子树

```c++
void xxx(BTree*& t){
    BTree* p;
    BTree* q;
    p = t;
    InitStack(s);
    while(p || !StackTmpty(s)){
        if(p){
            push(s,p);
            p = p->lchild;
        }else{
            pop(s,q);
            cout<<q->data<<endl;
            p = q->rchild;
        }
    }
}
```

#### 二叉树的层次遍历

1. 使用一个队列，将根节点入队
2. 队不空时循环：从队列中出列一个结点*p，访问它；
   - 如果它有左孩子结点，将左孩子结点进队
   - 如果它有右孩子结点，将右孩子结点进队

## 二叉树遍历的应用

### 二叉树创建

```c++
void createBTree(BTree& t){
    cin>>ch;
    if(ch == "#") t = NULL;
    else{
        t = new BTree*;
        t->data = ch;
        createBTree(t->lchild);
        createBTree(t->rchild);
    }
}
```

### 复制二叉树

```c++
int copy(BTree t,BTree& newt){
    if(t == NULL){
        newt = NULL;
        return 0;
    }else{
        newt = new BTree*;
        newt->data = t->data;
        copy(t->lchild,newt->lchild);
        copy(t->rchild,newt->rchild);
    }
}
```

### 计算二叉树深度

- 如果是空树，则深度为0
- 否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1

```c++
int depth(BTree t){
    if(t == NULL) return 0;
    else{
        m = depth(t->lchild);
        n = depth(t->rchild);
        if(m > n) return (m + 1);
        else return (n + 1);
    }
}
```

### 计算二叉树结点数

- 如果是空树，则结点数为0
- 否则，结点个数为左子树的结点个数+右子树的结点个数再+1

```c++
int NodeCount(BTree t){
    if(t == NULL) return 0;
    else{
        return NodeCount(t->lchild) + NodeCount(t->rchild) + 1;
    }
}
```

### 计算二叉树叶子结点数

- 如果是空树，则叶子结点个数为0
- 否则，为左子树的叶子结点个数+右子树叶子结点个数

```c++
int leadc(BTree t){
    if(t == NULL) return 0;
    if(t->lchild == NULL && t->rchild == NULL) return 1;
    else{
        return leadc(t->lchild) + leadc(t->rchild);
    }
}
```

## 线索二叉树

具有n个结点的二叉链表中，一共右2n个指针域；因为n个结点中有n-1个孩子，即2n个指针域中，有n-1个用来指示结点的左右孩子，其余n+1个指针域为空

利用二叉链表中的空指针域：

如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继——这种改变指向的指针称为线索，加上了线索的二叉树称为线索二叉树，增加线索的过程称为线索化

过程：先确定二叉树的遍历顺序，再根据顺序判断前驱后继，如果没有前驱后继则指针仍为空

为了区分lchild和rchild指针是指向孩子的指针还是指向前驱后继的指针，对二叉链表中每个结点曾设两个标志域ltag和rtag，并约定：

- ltag = 0	lchild指向该结点的左孩子
- ltag = 1    lchild 指向该结点的前驱
- rtag = 0    rchild 指向该结点的右孩子
- rtag = 1    rchild指向该结点的后继 



增设一个头节点：

ltag = 0 lchild指向根结点，rtag = 1 rchild指向遍历序列中最后一个结点，遍历序列中第一个结点的lc域和最后一个结点的rc域都指向头结点

## 树和森林

### 树的存储结构

#### 双亲表示法

实现：定义结构数组存放树的结点，每个结点含两个域

- 数据域：存放结点信息
- 双亲域：指示本结点的父节点在数组中的位置

特点：找父结点容易，找子结点难

#### 孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个节点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储

孩子结点结构：

- child：存放该结点在数组中的位置
- next：指向下一个孩子

父亲结点结构：

- data：数据
- fistchild：指向孩子链表的头指针

特点：找子结点任意，找父节点难

#### 孩子兄弟表示法（二叉树表示法，二叉链表表示法）

用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟节点

### 树与二叉树的转换

通过二叉链表做媒介

#### 将树转换成二叉树

1. 在兄弟之间加一条线
2. 对每个结点，除了其左孩子外，去除其与其余孩子之间的关系
3. 以树的根结点为轴心，将整树顺时针转45°

#### 将二叉树转换成树

1. 若p结点时父节点的左孩子，则将p的右孩子，右孩子的右孩子......沿分支找到所有右孩子，都与p的双亲用线连起来
2. 抹掉原二叉树中父节点与右孩子之间的连线
3. 将结点按层次排列，形成树结构

### 森林与二叉树的转换

#### 森林转换成二叉树

1. 将各棵树分别转换成二叉树
2. 将每棵树的根结点用线相连
3. 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针选择，构成二叉树型结构

#### 二叉树转换成森林

1. 将二叉树中根结点与其右孩子连线及沿右分支搜索到所有右孩子间连线全部抹掉，使之变成孤立的二叉树
2. 将鼓励的二叉树还原成树

### 树与森林的遍历

#### 树的遍历

- 先根（次序）遍历：若树不空，则先访问根节点，然后依次先根遍历各棵子树
- 后根（次序）遍历：若树不空，则先依次后根遍历各棵子树，然后访问根结点
- 按层次遍历：若树不空，则自上而下自左至右访问数中每个结点

#### 森林的遍历

将森林看作由三部分构成

1. 森林中第一棵树的根结点
2. 森林中第一棵树的子树森林
3. 森林中其它树构成的森林

##### 先序遍历

若森林不空，则

1. 访问森林中第一棵树的根结点
2. 先序遍历森林汇总第一棵树的子树森林
3. 先序遍历森林中（除第一棵树之外）其余树构成的森林

##### 中序遍历

若森林不空，则

1. 中序遍历森林中第一棵树的子树森林
2. 访问森林中第一棵树的根结点
3. 中序遍历森林中（除第一棵子树之外）其余树构成的森林

即：依次从左至右对森林中每一棵树进行后根遍历

## 哈夫曼树（最优二叉树）

判断树：用于描述分类过程的二叉树

路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

结点的路径长度：两结点间路径上的分支数

树的路径长度：从树根到每一个结点的路径长度之和，记作：TL

结点数目相同的二叉树中，完全二叉树是路径最短的二叉树，反之不一定

权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权

结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积

树的带权路径长度：树中所有叶子结点的带权路径之和

哈夫曼树：最优树 即带权路径长度（WPL）最短的树

带权路径长度最短是在度相同的树中比较而得的结果，因此有最优二叉树，最优三叉树等

满二叉树不一定是哈夫曼树；

哈夫曼树中权越大的叶子离根越近；

具有相同带权结点的哈夫曼树不唯一

贪心算法：构造哈夫曼树时首先选择权值小的叶子结点

哈夫曼树的结点度数为0或2，没有度为1的结点

包含n个叶子结点的哈夫曼树中共有2n-1个结点

### 哈夫曼算法（构造哈夫曼树的方法）

1. 根据n个给定的权值构成n棵二叉树的森林，其中每棵树只有一个带权的根结点
   - 构造森林全是根
2. 在森林中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
   - 选用两小造新树
3. 在森林中删除这两棵树，同时将新的二叉树加入森林中
   - 删除两小添新人
4. 重复2和3，直到森林中只有一棵树为止，这棵树即为哈夫曼树

### 哈夫曼树构造算法实现

采用顺序存储结构，即一维结构数组

```c++
typedef struct{
    int weight;
    int parent,lch,rch;
}htnode;




void crateht(htnode ht,int n){
    if(n <= 1) return;
    m = 2*n-1;//数组共2n-1个元素
    ht = new htnode[m+1];
    for(i = 1;i <= m;i ++){
        ht[i].lch = 0;
        ht[i].rch = 0;
        ht[i].parent = 0;
    }
    for(i = 1;i <= n;i ++) 
        cin >> ht[i].weight;
    
    for(i = n + 1;i <= m;i ++){//合并产生n-1个结点
        select(ht,i-1);//在ht[k](1<=k<=i-1)中选择两个其双亲域为0且权值最小的结点，并返回序号s1,s2
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].lch = s1;
        ht[i].rch = s2;
        ht[i].weight = ht[s1].weight + ht[s2].weight
    }
}
```

### 哈夫曼编码

1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）

2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短

3. 在哈夫曼树的每个分支上标上0或1：

   结点的左分支标0，右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码

性质1：哈夫曼编码是前缀码

性质2：哈夫曼编码是最优前缀码

```c++
//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表hc中
void cratehfc(htnode ht,hfc &hc,int n){
    hc = new char*[n+1];//分配n个字符编码的头指针矢量
    cd = new char[n];//临时存放编码的数组
    cd[n-1] = '\0';
    for(i = 1;i <= n;i ++){
        start = n-1;
        c = i;
        f = ht[i].parent;
        while(f != 0){//从叶子开始回溯，直到根结点
            start--;
            if(ht[f].lchild == c) cd[start] = '0';//c是f的左孩子，生成0
            else cd[start] = '1';//c是f的右孩子，生成1
            c = f;
            f = ht[f].parent;
        }
        hc[i] = new char[n-start];
        strcpy(hc[i],&cd[start]);
    }
    delete cd;
}
```

#### 文件的编码和解码

1. 编码
   - 输入各字符及其权值
   - 构造哈夫曼树——ht[i];
   - 进行哈夫曼编码——hc[i];
   - 查hc[i]，得到各字符的哈夫曼编码
2. 解码
   - 构造哈夫曼树
   - 依次读入二进制码
   - 读入0，则走向左孩子；读入1，则走向右孩子
   - 一旦到达某叶子时，即可译出字符
   - 然后再从根出发继续译码，直到结束

# 图

G = (V,E)

V：顶点（数据元素）的有穷非空集合

E：边的有穷集合

无向图：每条边都是无方向的

有向图：每条边都是有方向的

完全图：任意两个点都有一条边相连

无向完全图：n个顶点，n(n-1)/2条边

有向完全图：n个顶点，n(n-1)条边

稀疏图：有很少边或弧的图（e<nlogn）

​				无向称为边，有向称为弧



网：边/弧带权的图



邻接：有边/弧相连的两个顶点之间的关系

​	存在(vi,vj)，则称vi和vj互为邻接点；（无向图，圆括号表示不分先后顺序）

​	存在<vi,vj>，则称vi邻接到vj，vj邻接于vi；（有向图，尖括号表示分先后顺序）



关联（依附）：边/弧与顶点之间的关系

​	存在(vi,vj)/(vi,vj)，则称该边/弧关联于vi和vj



顶点的度：与该顶点相关联的边的数目，即位TD(v)



在有向图中，顶点的度等于该顶点的入度与出度之和

顶点v的入读是以v为终点的有向边的条数，记作ID(v)

顶点v的出度是以v为始点的有向边的条数，记作OD(v)



路径：接续的边构成的顶点序列

路径长度：路径上边或弧的数目/权值之和

回路（环）：第一个顶点和最后一个顶点相同的路径

简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径，即不重复经过

简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径，即绕了一圈



连通图（强连通图）：在无（有）向图G=(V,{E})中，若对任何两个顶点v，u都存在从v到u的路径，则称G是连通图（强连通图）



权与网：图中边或弧所具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费，带权的图称为网



子图：一个图的边和顶点是另一个图的一部分，则称这个图为另一个图的子图



连通分量（强连通分量）

- 无向图G的极大连通子图称为G的连通分量

  极大连通子图意思是：该子图是G连通子图，将G的任何不在孩子图中的顶点加入，子图不再连通

- 有向图G的极大连通子图称为G的强连通分量



极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通

生成树：包含无向图G所有顶点的极小连通子图

生成森林：对非连通图，由各个连通分量的生成树的集合
